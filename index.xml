<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://nuoccc.github.io/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 25 Jul 2019 17:11:09 +0800</lastBuildDate>
    
	<atom:link href="https://nuoccc.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Selector</title>
      <link>https://nuoccc.github.io/post/selector/</link>
      <pubDate>Thu, 25 Jul 2019 17:11:09 +0800</pubDate>
      
      <guid>https://nuoccc.github.io/post/selector/</guid>
      <description>本章内容为：《Selector基础》
作者：nuoccc
上一篇文章讲解了关于NIO基础的缓冲区Buffer以及通道Channel，这一篇文章我们主要讲关于选择器Selector的基础以及基于Selector我们进行服务器和客户机通讯。
Selector 一般称为选择器，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。
关于选择器的具体用法我们在代码中来详细使用和讲解。
按照正常思维创建服务器和客户机模型进行通讯一般是先创造服务器，而我觉得先创造客户机更能帮助我们理解这个通讯过程，不先创造客户机，你服务器怎么知道我客户机进行的操作，所以我的思想就是先解决客户机，先把“我”的需求写出来后，在用服务器去满足“我”的需求。
所以我们这次一样的先创建一个客户机，但是Selector其实并不用于客户机，只是用于服务器来选择跟哪个通道进行选择，所以我们客户机的代码就用Channel的客户机代码即可，这里快速写出来。
public class ChannelClient{ public static void main(String args[]){ Thread th = new Thread(new Client(&amp;quot;127.0.0.1&amp;quot;,8888));//这次我们创建线程来完成通讯	th.start(); } } class Client implements Runnable{ //创建一个线程 private SocketChannel socketChannel;//创建一个SocketChannel对象 private ByteBuffer readBuffer = ByteBuffer.allocate(1024);//开辟一个1k的字节读缓存区 private ByteBuffer writeBuffer = ByteBuffer.allocate(1024);//开辟一个1k的字节写缓存区 private String hostname; private int port; public Client (String hostname,int port){ this.hostname = hostname; this.port = port; } @Override public void run(){ //重写run方法 把我们要进行的主要步骤放里面 try{ socketChannel = SocketChannel.</description>
    </item>
    
    <item>
      <title>Nio</title>
      <link>https://nuoccc.github.io/post/nio/</link>
      <pubDate>Wed, 24 Jul 2019 16:02:33 +0800</pubDate>
      
      <guid>https://nuoccc.github.io/post/nio/</guid>
      <description>本章内容为：《NIO基础》
作者：nuoccc 首先我们来了解一下什么是NIO；  NIO全程 Non-block I/O 中文意思就是无阻塞读写流，然后在我们NIO中有三个核心对象需要掌握 缓冲区 （Buffer) 通道 (Channel) 选择器 (Selector) 这篇文章就针对上述这三点进行了解  一丶Buffer Buffer有四个属性：1.capacity 容量 2. limit 上限 3. position 当前位置 4. mark 标记 我们就直接通过一个程序来看看Buffer的API使用方法，以及加强对Buffer的四个属性的理解
InBuffer buffer = InBuffer.allocate(8);//我们先开辟一个长度为8的整型缓冲区 //buffer的使用本质上就是创建一个数组来进行缓存 for(int i = 0;i&amp;lt;6;i++){ buffer.put(i);//把当前的i放进buffer里面，这时候poition会向后移一位 //position可以理解为栈的栈顶，是在数据的高一位 } buffer.filp();//转化buffer的读写方式，默认为读方式，现在转化为写 while(buff.hasRemaining()){//可以理解为has.next(),判断是否还有数据 int j = buffer.get();//从buffer里面取数据，这里j其实就是buffer每个数据的下标 System.out.print(j+&amp;quot;&amp;quot;)//输出当前j，瞅瞅是否跟我们预期一样 } buffer.clear();//清空缓存区，重新读写 //说是清空，实际上是把当前的position又重新置为0，当put一个数据时，就会重新覆盖原来的数据 for(int i=0;i&amp;lt;buff.capacity();i++){ buffer.put(i); } buffer.flip(); while(buffer.hasReamining()){ int j = buffer.get(); System.out.println(j); }  其实Buffer还是挺好理解的，就是对一个数组进行读和写，但是我们后面的的都是基于buffer运行的。
二丶Channel 了解完Buffer之后我们来看看Channel(通道),那什么是Channel呢？ 我们首先来看一个图，来看看Channel的作用：
我们可以看出程序与程序之间数据传递并不是直接传递的，而是先通过Buffer然后再在Channel之间传递 根据上图，我们就可以设计出程序来进行通讯。 常用的Channel实现类有SocketChannel ServerSocketChannel DataGramChannel FileChannel ByteChannel 我们在实际使用中来熟悉Channel的用法</description>
    </item>
    
    <item>
      <title>HttpAndUdpSocket</title>
      <link>https://nuoccc.github.io/post/http/</link>
      <pubDate>Tue, 23 Jul 2019 15:36:30 +0800</pubDate>
      
      <guid>https://nuoccc.github.io/post/http/</guid>
      <description>本章内容为：《Http和UDP完成Socket通信基础》
作者：nuoccc 首先我们来了解一下什么是http以及它的工作原理 以下是百度百科关于http的说法:  HTTP是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。
 HTTP是基于客户/服务器模式，且面向连接的。典型的HTTP事务处理有如下的过程： （1）客户与服务器建立连接； （2）客户向服务器提出请求； （3）服务器接受请求，并根据请求返回相应的文件作为应答； （4）客户与服务器关闭连接。 大概的模型就像下图这样：   知道了工作原理，我们就通过工作原理来进行http的通讯编程。 首先我们先创立一个URL对象
URL url = new URL(&amp;quot;http://localhsot:8080/test/dream.jpg&amp;quot;)； //这里我用的是TOMCAT服务器，所以基础地址是localhost,端口号是8080， 后面是TOMCAT下的webapps下创建的test文件夹里面的dream图片  然后我们创建一个HttpURLconnection对象来获取url的连接
HttpURLConnection urlConn= (HttpURLConnection)url.openConnection(); //由于url.openConnection()返回的是一个URL对象所以我们必须要转化为子类HttpURLConnection才能接受。  然后进行一些相关属性的设置，熟练就行
urlConn.setConnectTimeout(5000);//设置连接的超时时间. urlConn.setReadTimeout(5000);//设置读取数据的超时时间 urlConn.setDoInput(true);//设置允许进行读操作 urlConn.setDoOutput(true);//设置允许进行写操作 urlConn.setRequestMethod(&amp;quot;GET&amp;quot;);//设置请求方式，http协议中指定提交方法有两种请求方式， 一个是GET,一个是POST；这里我们用默认的GET，具体差距这里不讨论  设置完属性后就可以从服务器下载数据了，但是我们还是要确认一下服务器是否响应成功
//首先创立一个接受码来获取服务器响应的状态码 int responseCode = urlConn.getResponseCode(); //然后进行判断是否跟系统的正确状态码相同 if(responseCode==HttpURLConnection.HTTP_OK){ //相同后我们就可以下载服务器数据了 //创建一个输入流来获取服务器的输入流 InputStream in = urlConn.getInputStream(); BufferedInputStream bis = new BufferedInputStream(in); //然后在创建一个输出流来读输入流 FileOutputStream fos = new FileOutputStream(new File(E:/test/test.png)); BufferedOutputStream bos = new BufferedOutputStream(fos); byte[] buf = new byte[1024]; int len = 0; while((len=bis.</description>
    </item>
    
    <item>
      <title>TcpSocket</title>
      <link>https://nuoccc.github.io/post/netcommution/</link>
      <pubDate>Mon, 22 Jul 2019 19:19:50 +0800</pubDate>
      
      <guid>https://nuoccc.github.io/post/netcommution/</guid>
      <description>本章内容为：《基于tcp完成Socket通信基础》
作者：nuoccc 首先我们来了解一下什么是TCP和UDP协议：  TCP协议：有连接协议，需要建立三次握手连接后才通讯，可以可靠的通讯，还可以处理数据出错的问题，因为有这些机制，所以通讯效率略低，但通讯是最可靠的。 Tcp实现的Socket通信是基于TCP三次握手，下面是TCP三次握手的流程图：  基于Tcp三次握手，改进为客户机和服务器进行Socket通信，于是可以变为下图:
我们基于这个图来完成对Socket通信的编程: 首先我们需要创建一个对象对客户机端口进行监听:
 ServerSocket serverSocket = new ServerSocket(8888);//里面放端口号，端口号一定要跟客户机通信端口一致 
这里我们要了解什么是端口号，端口号可以这样理解: 因为我们一台电脑对应一个ip地址，如果只有一个ip地址我们的应用也会只是单一的，但我们电脑现在都是多任务系统，同时有多个应用会进行通信，于是产生了端口号来解决这个问题，实现多通信。数据的发送和接收都需要通过端口出入计算机，端口号用于唯一标识通信实体上进行网络通讯的程序，同一台机器上不能两个程序占用同一个端口。了解完端口号，我们继续来说程序。 然后创立一个Socket 对象来完成连接
 Socket socket = serverSocket.accept(); 
完成好连接后就能进行数据的读写操作，我们用一个线程来完成这个步骤
 SockertThread th = new SocketThread(socket); 
然后创立好相应的线程类
class SocketThread extends Thread{ private Socket socket; public SocketThread(){ } public SocketThread(Socket socket){ this.socket=socket; } @Override public void run(){ try{ InputStream in = socket.getInputStream();//获取当前对象socket来获取客户机的输入流 byte[] b = new byte[1024]; in.read(b)//这里假设数据小于1024，一次读完，也可以用while来读数据 String info = new String(b);//创建一个字符串来接受获得的信息 System.</description>
    </item>
    
    <item>
      <title>Thread</title>
      <link>https://nuoccc.github.io/post/thread/</link>
      <pubDate>Thu, 18 Jul 2019 19:05:14 +0800</pubDate>
      
      <guid>https://nuoccc.github.io/post/thread/</guid>
      <description>本章内容为：《关于Thread类基础》 作者：nuoccc
java.lang 类 Thread java.lang.Object 继承者 java.lang.Thread 所有已实现的接口： Runnable  以上是 jdk 关于Thread的 视图
我们学习Thread类 就从提供的api入手
构造器  学一个类一般我们都是先学构造器，Thread有多个，但我们一般用两个 1.Thread()，默认构造器，用法为：
 Thread th = new Thread(); 
2.Thread(Runnable target),那Runnable是啥，我们看api底层定义
 @FunctionalInterface public interface Runnable { //中间一段注释我删了，有兴趣的可以自行通过底层查看 public abstract void run(); }  一目了然，Runnable是一个接口，定义了一个抽象方法run();所以我们在运用时就应该 使用一个实现了Runnable接口的对象我们从api视图可以知道，Thread实现了Runnable 接口，所以最常用的对象一般就是一个Thread的子类
  线程使用方法  一个类最关键的是如果使用，我们看api手册，给出的方法 1.创建新执行线程有两种方法。一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例。 2.创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动。 那我们根据手册给出的方法来使用Thread类
1.根据第一种方法我们先创立一个子类，这里名字取为sonThread继承Thread
class sonThread extends Thread { //会叫你重写一个run()方法，具体的定义为自己要执行的逻辑代码 //这里我们写一条输出语句随便测试下 @Override public void run() { System.</description>
    </item>
    
    <item>
      <title>关于File类基础以及遍历所有电脑文件</title>
      <link>https://nuoccc.github.io/post/file/</link>
      <pubDate>Tue, 16 Jul 2019 19:43:44 +0800</pubDate>
      
      <guid>https://nuoccc.github.io/post/file/</guid>
      <description>本章内容为：《关于File类基础以及遍历所有电脑文件》 作者：nuoccc
java.io
类 File
java.lang.Object
继承者 java.io.File
所有已实现的接口：
Serializable, Comparable
以上是 jdk 关于 File的 视图
我们学习File类 就从提供的api入手
构造器  首先File重写了四个构造方法 但这里之列举出我们最常用的两个构造方法 第一个File(File parent,String child);// 这个是通过父路径 以及子路径创建一个路径 第二个File(String pathname);//直接传入一个路径
 关于两种构造方法的实际应用具体如下：
1 File file = new File(&amp;quot;D:/&amp;quot;,&amp;quot;testFile.txt&amp;quot;); //创建一个路劲为D:/testFile.txt 的路径 2 File file2 = new File(&amp;quot;D:/testFile2.txt&amp;quot;); //创建一个路劲为D:/testFile2.txt 的路径   exists()  用exists()来判断文件是否存在；返回一个boolean值 存在返回true 不存在 返回 false。 exists()一般用来判断文件是否存在 不存在则创立一个新文件。 例如:
File file3 = new File(&amp;quot;D:/testFile3.txt&amp;quot;); if(!file3.exists()){//如果文件不存在则创建并提示创建成功，否则代表文件存在 file3.creatNewFile();//文件创建的方法 creatNewFile() System.out.println(&amp;quot;文件创建成功！&amp;quot;); }else{ System.</description>
    </item>
    
  </channel>
</rss>